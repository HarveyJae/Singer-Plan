# 线性表的定义：
- **线性表**是具有n个**相同类型元素**的**有限序列**。
- **注意**：
   - 线性表的**位序**从`1`开始，a1表示**表头**，an表示**表尾**。
# 线性表的逻辑结构：

- ![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1722873268221-40f21ed5-8e79-4dd8-a57e-2e4b8a8e4b57.png#averageHue=%23fdfdfb&clientId=ud34acc0a-38ab-4&from=paste&height=67&id=ua70b9c96&originHeight=133&originWidth=1003&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35452&status=done&style=none&taskId=uf2e5f94d-476e-4b07-9c12-d64c345e667&title=&width=501.5)
# 线性表的存储结构：
## 顺序存储(数组)：
### 静态数组实现顺序表：
```c
#define MAX_SIZE 10
typedef struct{
    ElemType data[MAX_SIZE];
    int length;
}SqList
//数组用来存储线性表中的各个节点。
```

- **问题**：
   - 静态分配大小无法更改，不能避免数组“满”。
   - 数组的初始容量分配过大会导“内存浪费”。
### 动态数组实现顺序表：
```c
#define INIT_SIZE 10;
typedef struct{
    ElemType *data;
    int maxSize;
    int length;
}SqList;
//动态数组
L.data = (ElemType *)malloc(sizeof(ElemType) * INIT_SIZE);
```
### 顺序存储分析：

- **优点**：
   - 查找元素的时间复杂度是**O(1)**。
      - **按值查找元素**(返回位序)的时间复杂度是**O(n)**。
   - 每个节点只存储**数据元素**，节省空间(存储密度高)。
- **缺点**：
   - 静态数组不允许拓展容量，当采用动态数组实现时，拓展容量的时间复杂度很高。
   - 插入、删除操作的时间复杂度是O(n)。
## 链式存储(链表)：
### 单链表：
```c
typedef struct 	LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;
//将该结构体重命名为LNode
//将该结构体的指针重命名为LinkList

//LinkList用来声明链表的头节点，表示整个单链表
//LNode用来声明链表的节点，表示节点
//二者区分开，增加代码的可读性

```
#### 单链表的操作：

- **带头节点**(常说的dummyHead)和**不带头节点**，通常在**选择题**中会考察，大题中直接通过**封装的函数操作**即可。
### 双链表：
```c
typedef struct DNode{
    ElemType data;
    struct DNode *pre;
    struct DNode *next;
}DNode, *DLinkList;
//pre用来存储前驱节点
//next用来存储后继节点
```
### 循环单链表：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1722950272694-45803e77-2ccc-4be4-ad3a-17452570606a.png#averageHue=%23fbf4ef&clientId=u37b00c12-27e2-4&from=paste&height=187&id=u9bb27609&originHeight=373&originWidth=1095&originalType=binary&ratio=2&rotation=0&showTitle=false&size=26687&status=done&style=none&taskId=u4ac86bc2-5540-43a1-abc8-a88c2463174&title=&width=547.5)
```c
//表尾的next指针指向表头L
//从一个节点出发，可以找到其他任何节点
```
### 循环双链表：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1722950359796-9e435679-a764-410c-9ebe-43a85891c452.png#averageHue=%23f9f0eb&clientId=u37b00c12-27e2-4&from=paste&height=154&id=uc5fc060e&originHeight=308&originWidth=1218&originalType=binary&ratio=2&rotation=0&showTitle=false&size=24398&status=done&style=none&taskId=u9bae1efb-b0ed-43fb-87e2-58b1cc05319&title=&width=609)

- 表尾的`next`指向表头，表头的`pre`指向表尾。
### 链式存储分析：

- **优点**：
   - 增删元素的时间复杂度是**O(1)**。
      - 增删元素之前需要定位到待操作节点的位置。
   - 离散空间分配，方便更改链表大小。
- **缺点**：
   - **查找元素**的时间复杂度是**O(n)**。
      - 不可随机存取。
   - 需要存储指针，花费额外空间，存储密度低。
# 线性表的基本操作：

- 创建、销毁、插入、删除、查找、长度、输出、判空。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1722873128776-7684aba7-2d34-4a36-a59e-758f80358252.png#averageHue=%23f7f4ef&clientId=ud34acc0a-38ab-4&from=paste&height=328&id=u3e0af721&originHeight=655&originWidth=1843&originalType=binary&ratio=2&rotation=0&showTitle=false&size=422959&status=done&style=none&taskId=u97b3c300-0b9b-42b1-86c7-35ea728148b&title=&width=921.5)

- `i`从`1`开始。
- `LocateElem()`返回的是元素的**位序**，位序从`1`开始。
- `GetElem()`返回的是**位序对应的元素**。
## 关于判断元素是否相等的一些问题：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/35940756/1722945747946-5b99ab15-7281-42aa-a354-3cbff43db0f8.png#averageHue=%23fcfaf9&clientId=u37b00c12-27e2-4&from=paste&height=544&id=u4d440c33&originHeight=1087&originWidth=2065&originalType=binary&ratio=2&rotation=0&showTitle=false&size=405785&status=done&style=none&taskId=u645fd8bc-1afd-481a-89a3-f825449d210&title=&width=1032.5)

